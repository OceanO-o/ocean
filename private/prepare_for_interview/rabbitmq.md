1.消息中间件的应用场景
    跨系统数据传递，高并发流量削峰，异步处理，解耦、削峰、异步下
2.消息中间件的本质
    它是一种接受数据，接受请求、存储数据、发送数据等功能的技术服务。
3.为什么消息中间件不直接使用http协议呢？
    1: 因为http请求报文头和响但是对于一个消息而言应报文头是比较复杂的，包含了cookie，数据的加密解密，状态码，
    响应码等附加的功能，，我们并不需要这么复杂，也没有这个必要性，
    它其实就是负责数据传递，存储，分发就行，一定要追求的是高性能。尽量简洁，快速。
    2:大部分情况下http大部分都是短链接，无状态的，当大量数据发送给消息中间件时，需要建立连接
    消耗资源太多
4.高可用模式都有哪些
    1.主从共享数据 2.master slave 主从同步 3.多主集群同步部署
5.rabbitmq 交换机几种模式
    fanout模式，广播模式
    Fanout模式不处理路由键，一个发送到exchange的消息都会被转发到与该exchange绑定的所有队列上
    direct模式，根据路由分发消息。Direct模式是fanout模式上的一种叠加，增加了路由RoutingKey的模式。
    topic模式，模糊路由匹配。Topic模式是direct模式上的一种叠加，增加了模糊路由RoutingKey的模式。
    work模式
        当有多个消费者时，我们的消息会被哪个消费者消费呢，我们又该如何均衡消费者消费信息的多少呢?
        主要有两种模式：
        1、轮询模式的分发：一个消费者一条，按均分配；
        2、公平分发：根据消费者的消费能力进行公平分发，处理快的处理的多，处理慢的处理的少；按劳分配；
6.ttl过期时间
    第一种方法是通过队列属性设置，队列中所有消息都有相同的过期时间。
    第二种方法是对消息进行单独设置，每条消息TTL可以不同。
    如果上述两种方法同时使用，则消息的过期时间以两者之间TTL较小的那个数值为准。
    消息在队列的生存时间一旦超过设置的TTL值，就称为dead message被投递到死信队列， 
    消费者将无法再收到该消息。
7.死信队列
    DLX，全称为Dead-Letter-Exchange , 可以称之为死信交换机，也有人称之为死信邮箱。
    当消息在一个队列中变成死信(dead message)之后，它能被重新发送到另一个交换机中，
    这个交换机就是DLX ，绑定DLX的队列就称之为死信队列。消息变成死信，可能是由于以下的原因：
        消息被拒绝
        消息过期
        队列达到最大长度
    DLX也是一个正常的交换机，和一般的交换机没有区别，它能在任何的队列上被指定，实际上就是设置
    某一个队列的属性。当这个队列中存在死信时，Rabbitmq就会自动地将这个消息重新发布到设置的DLX上去，
    进而被路由到另一个队列，即死信队列。
    要想使用死信队列，只需要在定义队列的时候设置队列参数 x-dead-letter-exchange 指定交换机即可。
8.持久化
RabbitMQ的持久化队列分为：
    1：队列持久化 队列的持久化是定义队列时的durable参数来实现的，Durable为true时，队列才会持久化
            channel.queueDeclare(queueName,true,false,false,null);
    2：消息持久化 消息持久化是通过消息的属性deliveryMode来设置是否持久化，在发送消息时通过basicPublish的参数传入。
        channel.basicPublish(exchangeName, routingKey1, deliverymode, message.getBytes());
    3：交换机持久化 和队列一样，交换机也需要在定义的时候设置持久化的标识，否则在rabbit-server服务重启以后将丢失。
        channel.exchangeDeclare(exchangeName,exchangeType,true); 第三个参数
    不论是持久化的消息还是非持久化的消息都可以写入到磁盘中，
    只不过非持久的是等内存不足的情况下才会被写入到磁盘中。
9.rabbitmq磁盘监控
    RabbitMQ的内存控制
    当内存使用超过配置的阈值或者磁盘空间剩余空间对于配置的阈值时，RabbitMQ会暂时阻塞客户端的连接，
    并且停止接收从客户端发来的消息，以此避免服务器的崩溃，客户端与服务端的心态检测机制也会失效。
    rabbitmqctl set_vm_memory_high_watermark <fraction>
    fraction/value 为内存阈值。默认情况是：0.4/2GB，代表的含义是：当RabbitMQ的内存超过40%时，
    就会产生警告并且阻塞所有生产者的连接。通过此命令修改阈值在Broker重启以后将会失效，
    通过修改配置文件方式设置的阈值则不会随着重启而消失，但修改了配置文件一样要重启broker才会生效。
    RabbitMQ的内存换页
    在某个Broker节点及内存阻塞生产者之前，它会尝试将队列中的消息换页到磁盘以释放内存空间，
    持久化和非持久化的消息都会写入磁盘中，其中持久化的消息本身就在磁盘中有一个副本，
    所以在转移的过程中持久化的消息会先从内存中清除掉。    
    
    
    
    
