1.如何知道一个python对象的类型
    使用type(a)
    isinstance(a, b)用来判断是否为一个已知类型，并且可以判断对象是否属于父类
    type只接受一个参数，若B继承A, b为B的对象，type(b)只能是B无法知道属不属于A的对象，instance可以
2.*args 和 **kwargs 的区别，是否可以同时定义，有没有先后顺序
    可变参数允许你将不定数量的参数传递给函数，而关键字参数则允许你将不定长度的键值对
    作为参数传递给一个函数
    函数参数 依次是必选参数、默认参数、可变参数和关键字参数
    def func(x, y, z=0, *args, **kwargs):  *() **{}, 打包，使用时解包
    *args 和 **kwargs分别是可变参数和关键字参数
    在传递参数时会进行打包，将多于参数打包成一个元组或字典，在函数内部使用是会进行解包
3.直接交换变量的本质
    a, b = b, a
    t = b, a type(t)=tuple， 右边是一个元组
    左边就相当于元组拆包的过程
    拆包有两种方式 1.同等个数的变量接收一个元组 a, b= (a, b) 2.*进行解包 *(a, b)
    sequence
4.ll = [1, 2, 3, 4]
    ll[10:]输出            输出为[]
5.类变量在子父类中被修改时引起的变化
    见s_f_change.py
6.sqlclehemy动态增加字段
    使用setattr(object, name, value)
    
    
    
22.yield的使用场景
    1.yield会中断代码执行，所以可以在yield之前打开一个资源，yield之后释放一个资源，比如
    上下文管理器 2.yield节约内存，不要一下子加载所有资源
21.闭包
    闭包描述的是：脱离了函数的作用域范围，局部变量还可以被访问得到
23.装饰器
    装饰器本质上是一个Python函数，它可以让其他函数在不需要做任何代码变动的前提下增加额外
    功能，装饰器的返回值也是一个函数对象。插入日志、性能测试、事务处理、缓存、权限校验等场景
    类装饰器实现__call__方法
    使用functools.wraps装饰器保留原函数的元信息
22.迭代器生成器上下文管理器
    迭代器：指遵循迭代器协议的对象，迭代器协议指的是实现了iter方法和next方法的对象
    iter方法返回对象本身，next方法返回下一个元素，在没有下一个元素时抛出异常
    生成器：Python有两种提供生成器的方式
        生成器函数：包含yield语句的函数，返回一个生成器对象
        生成器表达式：生成器按需返回一个结果，而不是一次构建一整个列表
        生成器使用yield返回一个值，yield语句挂起该生成器的状态，保留信息，以便从中断的地方继续执行
    区别：迭代器只能记住自身的执行状态并等待下一次迭代，而生成器除了也会记住执行状态，
    还可以通过yield语句控制使多个生成器切换执行
    上下文管理器：实现了enter和exit方法的对象
7.进程线程和协程的区别 以及GIL锁
    GIL锁使得python解释器在同一时间只能运行一个线程，无法有效的使用多线程实现多核任务
    进程：进程是正在运行的程序的实例，包括内存空间，数据栈等
    线程：是进程中的一个实体，一个进程至少包含一个线程
    进程拥有自己的内存空间和数据栈，多个线程共享继承的内存数据栈
    协程：通过yield在子程序内部中断，然后转而执行别的子程序，在适当的时候再返回来接着执行。
    和线程的区别：没有线程切换的开销，和多线程比，线程数量越多，协程的性能优势就越明显。
    不需要多线程的锁机制
12.python2和3的区别
    字符编码：python2默认使用ascii，python3使用utf-8
    python2中字符串有两种类型，str和unicode str是bytes类型的，是字节码，unicode需要编码才能变成字节码
    当unicode字符串和str字符串拼接时就会出现隐式类型转换，str类型(字符串'你好')会进行解码，而默认编解码
    方式为ascii，对于中文就会解码报错。同样当传递一个unicode字符串给函数时，会进行字符串编码成byte，此时
    就会编码报错。
    对一些库做了更改，引用方式修改
    对print更改，py2中 print后跟一个元组对象 py3中是一个函数，可接受变长参数
    py3 添加了nolocal
    except Exception, e变成except (Exception) as e
    高阶函数 map、filter、zip 返回的也都不是列表对象了,而是一个类
    py3都是新式类，mro为广度优先，旧时类为深度优先
20.元类?
    类是实例对象的模板，元类是类的模板
    通过定义一个类A, B继承A, 并且_metaclass__ = PrefixMetaclass
    "Python 会首先在当前类中寻找 __metaclass__，如果没有找到，就会在父类中寻找 __metaclass__"
    "如果找不到，如此继续下去，如果在任何父类都找不到 __metaclass__，就会到模块层次中寻找，"
    "如果还是找不到，就会用 type 来创建这个类。"
    # 元类主要做了三件事：
    # 拦截类的创建
    # 修改类的定义
    # 返回修改后的类
    # 当你创建类时，解释器会调用元类来生成它，定义一个继承自 object 的普通类意味着调用 type 来创建它
21.垃圾回收机制
    python垃圾回收机制：引用计数为主（循环引用无法解决），标记清除和隔代回收为辅    
    标记清除解决循环引用问题，算法中有一个链表unreachedable，从A出发，因为它对B有一个引用，就把B
    的引用计数减一，顺着引用到达B，它有一个对A的引用，将A的引用计数减一，最终引用计数为0就被回收 
    隔代回收，新生对象被放在第一代，超过阀值清除，没清除掉进入第二代，直到第三代每一代有一个阈值
22.深浅拷贝
    对不可变对象来说，深浅拷贝都是对原对象的一份引用，通过引用计数可以查看
    对于可变对象来说：
        深拷贝会开辟一个新的内存地址，并拷贝所有元素，包括多层嵌套的元素，深拷贝对象和原对象没有任何关联
        浅拷贝[1, 2, [2, 3]]   []
            拷贝对象中无复杂子对象
                改变原对象元素的值不会影响新对象元素的值
            拷贝对象中有复杂子对象
                改变原对象复杂对象的值，会影响新对象元素的值
11.python的最大特点
    简洁，高级，面向对象，可移植性，强大而丰富的库
13.python常用类库
    requests sqlalchemy celery gunicorn flask click redis os functools 
17.python pass作用
    占位，保证语义的完整性
18.python 单引号双引号三引号区别
    单引号和双引号都可以用来表示一个字符串
    单引号双引号套用，避免转义
    字符串写成多行不用换行符，使用三引号
    注释也可使用三引号
19.filter reduce map 示例， 高阶函数
    lambda x: x * x
    map(lambda x: x * x, [1, 2, 3]) 将一个列表映射到另一个列表
    reduce(lambda x: x + x, [1, 2, 3]) 将一个列表归纳为一个输出
    filter(lambda x: x%2 == 0, [1, 2, 3]) 过滤列表的一些元素
    [x for item in sequence if condition] x是对item的操作，输出一个列表
    [x+2 for x in [1, 2, 3]]
16.正则表达式
    匹配除了任何小写字母和数字的所有字符
    任意匹配换行符 \n \r
    re.match和re.search区别 re.sub作用
    re.match match 函数不能指定字符串的区间，它只能搜索头部，
    re.search 匹配整个字符串，只要包含匹配的就返回
17.手写一个协程，迭代器实现斐波那契数列
18.装饰器和带参数装饰器实现写一个，闭包也写一个
18.手写单例模式，装饰器模式实现闭包